# algorithme-structures_of_date

#### Solving the puzzles using javascript + algorithms


## [ua]
# Швидкість алгоритмів визначається через "О-велике".
__"O-велике" пояснює кількість операцій необхідних для виконання алгоритму і має вигляд O(n).__
Наприклад бінарний пошук має складність $`log  n`$, тоді як простий пошук(перевірка кожного елемента по черзі) - O(n), де n - це кількість елементів в масиві даних. І порінюючи ці два методи пошуку бінарни ошук на кожному кроці зменшує кількість елементів вдвічі, в той час простий пошук буде перевіряти кожен елемент по черзі.


__Логарифм__ - _це операція, зворотня піднесенню в степені._

Приклад:
| Степені        | Логарифми |
|--------------|-----------|
| $$10^2 = 100$$    |  $$log_{10} 100 = 2$$ |
| $$10^3 = 1000$$ | $$log_{10} 1000 = 3$$ |
| $$2^3 = 8$$    | $$log_2 8 = 3$$ |
| $$2^4 = 16$$  | $$log_2 16 = 4$$ |
| $$2^5 = 32$$   | $$log_2 32 = 5$$ |


Для списку з 8 елементів знадобиться не більше 8 перевірок.
Для бінарного пошуку знадобиться в найгіршому випадку не більше log n перевірок.
$`log_8`$ == 3, бо $`2^3`$ == 8
для списка з 8 чисел вам знадобиться перевірити не більше 3 чисел.
Для списка з 1024 знадобиться не більше 10 перевірок, тому що $`log_{2} 1024`$ = 10, бо $`2^{10}`$ == 1024

 - $$О(n)$$ $$лінійний -час. Приклад: простий -пошук.$$
 - $$O(log n)$$ $$логарифмічний -час. Приклад: бінарний -пошук.$$
 - $$O(n * log n)$$ $$приклад: ефективні -алгоритми -сортування(швидке -сортування).$$
 - $$O(n^2)$$ $$приклад: повільний -алгоритм -сортування(сортування -вибором).$$
 - $$O(n!)$$ $$приклад: дуже -повільний -алгоритм -сортування(задача -про -комівояжера).$$

Наглядний приклад алгоритма
Нам необхідно накреслити 16 квадратів на листку паперу, ми можемо креслити квадрат за квадратои і це буде 16 операцій О(n), або ж ми можему 4 рази сгорнути лист паперу і отримати 16 квадратів на місті згибів O(log n).






